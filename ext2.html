<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML
><HEAD
><TITLE
>The Second Extended File System</TITLE
><META
NAME="GENERATOR"
CONTENT="Modular DocBook HTML Stylesheet Version 1.64
"></HEAD
><BODY
CLASS="BOOK"
BGCOLOR="#FFFFFF"
TEXT="#000000"
LINK="#0000FF"
VLINK="#840084"
ALINK="#0000FF"
><DIV
CLASS="BOOK"
><A
NAME="EXT2.INTERNALS"
></A
><DIV
CLASS="TITLEPAGE"
><H1
CLASS="TITLE"
><A
NAME="AEN2"
>The Second Extended File System</A
></H1
><H2
CLASS="SUBTITLE"
>Internal Layout</H2
><H3
CLASS="AUTHOR"
><A
NAME="AEN6"
>Dave Poirier</A
></H3
><DIV
CLASS="AFFILIATION"
><DIV
CLASS="ADDRESS"
><P
CLASS="ADDRESS"
>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;instinc@users.sf.net<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</P
></DIV
></DIV
><P
CLASS="COPYRIGHT"
>Copyright &copy; 2001-2002 by Dave Poirier</P
><DIV
CLASS="LEGALNOTICE"
><A
NAME="AEN15"
></A
><P
></P
><P
>	Permission is granted to copy, distribute and/or modify this document
	under the terms of the GNU Free Documentation License, Version 1.1
	or any later version published by the Free Software Foundation;
	with no Invariant Sections, with no Front-Cover Texts, and with no
	Back-Cover Texts. A copy of the license can be acquired electronically
	from http://www.fsf.org/licenses/fdl.html or by writing to 
	59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
   </P
><P
></P
></DIV
><HR></DIV
><DIV
CLASS="TOC"
><DL
><DT
><B
>Table of Contents</B
></DT
><DT
><A
HREF="#AEN18"
>About this book</A
></DT
><DT
>1. <A
HREF="#DISK-ORGANISATION"
>Disk Organisation</A
></DT
><DD
><DL
><DT
>1.1. <A
HREF="#SUPERBLOCK"
>superblock</A
></DT
><DD
><DL
><DT
>1.1.1. <A
HREF="#S-INODES-COUNT"
>s_inodes_count</A
></DT
><DT
>1.1.2. <A
HREF="#S-BLOCKS-COUNT"
>s_blocks_count</A
></DT
><DT
>1.1.3. <A
HREF="#S-R-BLOCKS-COUNT"
>s_r_blocks_count</A
></DT
><DT
>1.1.4. <A
HREF="#S-FREE-BLOCKS-COUNT"
>s_free_blocks_count</A
></DT
><DT
>1.1.5. <A
HREF="#S-FREE-INODES-COUNT"
>s_free_inodes_count</A
></DT
><DT
>1.1.6. <A
HREF="#S-FIRST-DATA-BLOCK"
>s_first_data_block</A
></DT
><DT
>1.1.7. <A
HREF="#S-LOG-BLOCK-SIZE"
>s_log_block_size</A
></DT
><DT
>1.1.8. <A
HREF="#S-LOG-FRAG-SIZE"
>s_log_frag_size</A
></DT
><DT
>1.1.9. <A
HREF="#S-BLOCKS-PER-GROUP"
>s_blocks_per_group</A
></DT
><DT
>1.1.10. <A
HREF="#S-FRAGS-PER-GROUP"
>s_frags_per_group</A
></DT
><DT
>1.1.11. <A
HREF="#S-INODES-PER-GROUP"
>s_inodes_per_group</A
></DT
><DT
>1.1.12. <A
HREF="#S-MTIME"
>s_mtime</A
></DT
><DT
>1.1.13. <A
HREF="#S-WTIME"
>s_wtime</A
></DT
><DT
>1.1.14. <A
HREF="#S-MNT-COUNT"
>s_mnt_count</A
></DT
><DT
>1.1.15. <A
HREF="#S-MAX-MNT-COUNT"
>s_max_mnt_count</A
></DT
><DT
>1.1.16. <A
HREF="#S-MAGIC"
>s_magic</A
></DT
><DT
>1.1.17. <A
HREF="#S-STATE"
>s_state</A
></DT
><DT
>1.1.18. <A
HREF="#S-ERRORS"
>s_errors</A
></DT
><DT
>1.1.19. <A
HREF="#S-MINOR-REV-LEVEL"
>s_minor_rev_level</A
></DT
><DT
>1.1.20. <A
HREF="#S-LASTCHECK"
>s_lastcheck</A
></DT
><DT
>1.1.21. <A
HREF="#S-CHECKINTERVAL"
>s_checkinterval</A
></DT
><DT
>1.1.22. <A
HREF="#S-CREATOR-OS"
>s_creator_os</A
></DT
><DT
>1.1.23. <A
HREF="#S-REV-LEVEL"
>s_rev_level</A
></DT
><DT
>1.1.24. <A
HREF="#S-DEF-RESUID"
>s_def_resuid</A
></DT
><DT
>1.1.25. <A
HREF="#S-DEF-RESGID"
>s_def_resgid</A
></DT
><DT
>1.1.26. <A
HREF="#S-FIRST-INO"
>s_first_ino</A
></DT
><DT
>1.1.27. <A
HREF="#S-INODE-SIZE"
>s_inode_size</A
></DT
><DT
>1.1.28. <A
HREF="#S-BLOCK-GROUP-NR"
>s_block_group_nr</A
></DT
><DT
>1.1.29. <A
HREF="#S-FEATURE-COMPAT"
>s_feature_compat</A
></DT
><DT
>1.1.30. <A
HREF="#S-FEATURE-INCOMPAT"
>s_feature_incompat</A
></DT
><DT
>1.1.31. <A
HREF="#S-FEATURE-RO-COMPAT"
>s_feature_ro_compat</A
></DT
><DT
>1.1.32. <A
HREF="#S-UUID"
>s_uuid</A
></DT
><DT
>1.1.33. <A
HREF="#S-VOLUME-NAME"
>s_volume_name</A
></DT
><DT
>1.1.34. <A
HREF="#S-LAST-MOUNTED"
>s_last_mounted</A
></DT
><DT
>1.1.35. <A
HREF="#S-ALGO-BITMAP"
>s_algo_bitmap</A
></DT
></DL
></DD
><DT
>1.2. <A
HREF="#GROUP-DESCRIPTOR"
>Group Descriptor</A
></DT
><DD
><DL
><DT
>1.2.1. <A
HREF="#BG-BLOCK-BITMAP"
>bg_block_bitmap</A
></DT
><DT
>1.2.2. <A
HREF="#BG-INODE-BITMAP"
>bg_inode_bitmap</A
></DT
><DT
>1.2.3. <A
HREF="#BG-INODE-TABLE"
>bg_inode_table</A
></DT
><DT
>1.2.4. <A
HREF="#BG-FREE-BLOCKS-COUNT"
>bg_free_blocks_count</A
></DT
><DT
>1.2.5. <A
HREF="#BG-FREE-INODES-COUNT"
>bg_free_inodes_count</A
></DT
><DT
>1.2.6. <A
HREF="#BG-USED-DIRS-COUNT"
>bg_used_dirs_count</A
></DT
><DT
>1.2.7. <A
HREF="#BG-PAD"
>bg_pad</A
></DT
><DT
>1.2.8. <A
HREF="#BG-RESERVED"
>bg_reserved</A
></DT
></DL
></DD
><DT
>1.3. <A
HREF="#BLOCK-BITMAP"
>Block Bitmap</A
></DT
><DT
>1.4. <A
HREF="#INODE-BITMAP"
>Inode Bitmap</A
></DT
><DT
>1.5. <A
HREF="#INODE-TABLE"
>Inode Table</A
></DT
><DD
><DL
><DT
>1.5.1. <A
HREF="#I-MODE"
>i_mode</A
></DT
><DT
>1.5.2. <A
HREF="#I-UID"
>i_uid</A
></DT
><DT
>1.5.3. <A
HREF="#I-SIZE"
>i_size</A
></DT
><DT
>1.5.4. <A
HREF="#I-ATIME"
>i_atime</A
></DT
><DT
>1.5.5. <A
HREF="#I-CTIME"
>i_ctime</A
></DT
><DT
>1.5.6. <A
HREF="#I-MTIME"
>i_mtime</A
></DT
><DT
>1.5.7. <A
HREF="#I-DTIME"
>i_dtime</A
></DT
><DT
>1.5.8. <A
HREF="#I-GID"
>i_gid</A
></DT
><DT
>1.5.9. <A
HREF="#I-LINKS-COUNT"
>i_links_count</A
></DT
><DT
>1.5.10. <A
HREF="#I-BLOCKS"
>i_blocks</A
></DT
><DT
>1.5.11. <A
HREF="#I-FLAGS"
>i_flags</A
></DT
><DT
>1.5.12. <A
HREF="#I-OSD1"
>i_osd1</A
></DT
><DT
>1.5.13. <A
HREF="#I-BLOCK"
>i_block</A
></DT
><DT
>1.5.14. <A
HREF="#I-GENERATION"
>i_generation</A
></DT
><DT
>1.5.15. <A
HREF="#I-FILE-ACL"
>i_file_acl</A
></DT
><DT
>1.5.16. <A
HREF="#I-DIR-ACL"
>i_dir_acl</A
></DT
><DT
>1.5.17. <A
HREF="#I-FADDR"
>i_faddr</A
></DT
><DT
>1.5.18. <A
HREF="#I-OSD2"
>i_osd2</A
></DT
></DL
></DD
><DT
>1.6. <A
HREF="#DATA-BLOCKS"
>Data Blocks</A
></DT
></DL
></DD
><DT
>2. <A
HREF="#DIRECTORY"
>Directory Structure</A
></DT
><DD
><DL
><DT
>2.1. <A
HREF="#IFDIR"
>Directory File Format</A
></DT
><DD
><DL
><DT
>2.1.1. <A
HREF="#IFDIR-INODE"
>inode</A
></DT
><DT
>2.1.2. <A
HREF="#IFDIR-REC-LEN"
>rec_len</A
></DT
><DT
>2.1.3. <A
HREF="#IFDIR-NAME-LEN"
>name_len</A
></DT
><DT
>2.1.4. <A
HREF="#IFDIR-FILE-TYPE"
>file_type</A
></DT
><DT
>2.1.5. <A
HREF="#IFDIR-NAME"
>name</A
></DT
></DL
></DD
><DT
>2.2. <A
HREF="#DIR-SAMPLE"
>Sample Directory</A
></DT
><DT
>2.3. <A
HREF="#INDEXED-DIRECTORY"
>Indexed Directory Format</A
></DT
><DD
><DL
><DT
>2.3.1. <A
HREF="#CONTRIB-INDEX-STRUCTURE"
>Index Structure</A
></DT
><DT
>2.3.2. <A
HREF="#CONTRIB-LOOKUP-ALGORITHM"
>Lookup Algorithm</A
></DT
><DT
>2.3.3. <A
HREF="#CONTRIB-INSERT-ALGORITHM"
>Insert Algorithm</A
></DT
><DT
>2.3.4. <A
HREF="#CONTRIB-SPLITTING"
>Splitting</A
></DT
><DT
>2.3.5. <A
HREF="#CONTRIB-KEY-COLLISIONS"
>Key Collisions</A
></DT
><DT
>2.3.6. <A
HREF="#CONTRIB-HASH-FUNCTION"
>Hash Function</A
></DT
><DT
>2.3.7. <A
HREF="#CONTRIB-PERFORMANCE"
>Performance</A
></DT
></DL
></DD
></DL
></DD
><DT
>3. <A
HREF="#AEN838"
>Inodes, file identifiers</A
></DT
><DD
><DL
><DT
>3.1. <A
HREF="#INODE-NUMBER"
>Inode Number</A
></DT
><DT
>3.2. <A
HREF="#AEN849"
>Locating the Inode structure</A
></DT
><DT
>3.3. <A
HREF="#AEN862"
>Locating the Inode Table</A
></DT
></DL
></DD
><DT
>4. <A
HREF="#AEN870"
>File Attributes</A
></DT
><DD
><DL
><DT
>4.1. <A
HREF="#AEN874"
>Standard Attributes</A
></DT
><DD
><DL
><DT
>4.1.1. <A
HREF="#AEN876"
>SUID, SGID and -rwxrwxrwx</A
></DT
><DT
>4.1.2. <A
HREF="#AEN880"
>File Size</A
></DT
><DT
>4.1.3. <A
HREF="#AEN884"
>Owner and Group</A
></DT
></DL
></DD
><DT
>4.2. <A
HREF="#CONTRIB-EXTENDED-ATTRIBUTES"
>Extended Attributes</A
></DT
><DD
><DL
><DT
>4.2.1. <A
HREF="#AEN907"
>Attribute Block Header</A
></DT
><DT
>4.2.2. <A
HREF="#AEN928"
>Attribute Entry Header</A
></DT
></DL
></DD
><DT
>4.3. <A
HREF="#BEHAVIOUR-FLAGS"
>Behaviour Control Flags</A
></DT
><DD
><DL
><DT
>4.3.1. <A
HREF="#EXT2-SECRM-FL"
>EXT2_SECRM_FL - Secure Deletion</A
></DT
><DT
>4.3.2. <A
HREF="#EXT2-UNRM-FL"
>EXT2_UNRM_FL - Record for Undelete</A
></DT
><DT
>4.3.3. <A
HREF="#EXT2-COMPR-FL"
>EXT2_COMPR_FL - Compressed File</A
></DT
><DT
>4.3.4. <A
HREF="#EXT2-SYNC-FL"
>EXT2_SYNC_FL - Synchronous Updates</A
></DT
><DT
>4.3.5. <A
HREF="#EXT2-IMMUTABLE-FL"
>EXT2_IMMUTABLE_FL - Immutable File</A
></DT
><DT
>4.3.6. <A
HREF="#EXT2-APPEND-FL"
>EXT2_APPEND_FL - Append Only</A
></DT
><DT
>4.3.7. <A
HREF="#EXT2-NODUMP-FL"
>EXT2_NODUMP_FL - Do No Dump/Delete</A
></DT
><DT
>4.3.8. <A
HREF="#EXT2-NOATIME-FL"
>EXT2_NOATIME_FL - Do Not Update .i_atime</A
></DT
><DT
>4.3.9. <A
HREF="#EXT2-DIRTY-FL"
>EXT2_DIRTY_FL - Dirty</A
></DT
><DT
>4.3.10. <A
HREF="#EXT2-COMPRBLK-FL"
>EXT2_COMPRBLK_FL - Compressed Blocks</A
></DT
><DT
>4.3.11. <A
HREF="#EXT2-NOCOMPR-FL"
>EXT2_NOCOMPR_FL - Access Raw Compressed Data</A
></DT
><DT
>4.3.12. <A
HREF="#EXT2-ECOMPR-FL"
>EXT2_ECOMPR_FL - Compression Error</A
></DT
><DT
>4.3.13. <A
HREF="#EXT2-BTREE-FL"
>EXT2_BTREE_FL - B-Tree Format Directory</A
></DT
><DT
>4.3.14. <A
HREF="#EXT2-INDEX-FL"
>EXT2_INDEX_FL - Hash Indexed Directory</A
></DT
><DT
>4.3.15. <A
HREF="#EXT2-IMAGIC-FL"
>EXT2_IMAGIC_FL -</A
></DT
><DT
>4.3.16. <A
HREF="#EXT3-JOURNAL-DATA-FL"
>EXT2_JOURNAL_DATA_FL - Journal File Data</A
></DT
><DT
>4.3.17. <A
HREF="#EXT2-RESERVED-FL"
>EXT2_RESERVED_FL - Reserved</A
></DT
></DL
></DD
></DL
></DD
><DT
>A. <A
HREF="#AEN1116"
>Credits</A
></DT
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Tables</B
></DT
><DT
>1-1. <A
HREF="#EXT2-ERRORS"
>EXT2_ERRORS values</A
></DT
><DT
>1-2. <A
HREF="#EXT2-OS"
>EXT2_OS values</A
></DT
><DT
>1-3. <A
HREF="#AEN252"
>EXT2 revisions</A
></DT
><DT
>1-4. <A
HREF="#AEN416"
>EXT2_*_INO values</A
></DT
><DT
>1-5. <A
HREF="#AEN450"
>EXT2_S_I values</A
></DT
><DT
>2-1. <A
HREF="#AEN725"
>EXT2_FT values</A
></DT
><DT
>4-1. <A
HREF="#AEN967"
>Behaviour Control Flags</A
></DT
></DL
></DIV
><DIV
CLASS="LOT"
><DL
CLASS="LOT"
><DT
><B
>List of Figures</B
></DT
><DT
>1-1. <A
HREF="#AEN37"
>floppy disk meta-data layout</A
></DT
><DT
>1-2. <A
HREF="#AEN47"
>20mb partition meta-data layout</A
></DT
><DT
>1-3. <A
HREF="#AEN80"
>superblock structure</A
></DT
><DT
>1-4. <A
HREF="#AEN312"
>group_desc structure</A
></DT
><DT
>1-5. <A
HREF="#INODE"
>inode structure</A
></DT
><DT
>1-6. <A
HREF="#AEN625"
>inode osd2 structure: Hurd</A
></DT
><DT
>1-7. <A
HREF="#AEN656"
>inode osd2 structure: Linux</A
></DT
><DT
>1-8. <A
HREF="#AEN679"
>inode osd2 structure: Masix</A
></DT
><DT
>2-1. <A
HREF="#AEN703"
>directory entry</A
></DT
><DT
>2-2. <A
HREF="#AEN776"
>Sample Directory Data Layout</A
></DT
><DT
>2-3. <A
HREF="#AEN829"
>Performance of Indexed Directories</A
></DT
><DT
>3-1. <A
HREF="#INODE-COMPUTATION"
>Sample inode computations</A
></DT
><DT
>4-1. <A
HREF="#AEN909"
>ext2_xattr_header structure</A
></DT
><DT
>4-2. <A
HREF="#AEN930"
>ext2_xattr_header structure</A
></DT
></DL
></DIV
><DIV
CLASS="PREFACE"
><HR><H1
><A
NAME="AEN18"
>About this book</A
></H1
><P
>	The latest version of this document may be downloaded from
	http://www.freesoftware.fsf.org/ext2-doc/
  </P
><P
>	This book is intended as an  introduction  and  guide  to  the  Second
	Extended File System, also known as Ext2.  The reader  should  have  a
	good understanding of the purpose of a file  system  as  well  as  the
	associated vocabulary (file, directory, partition, etc).
  </P
><P
>	Trying to implement ext2 drivers isn't always an easy task,  the  most
	difficult issue is unfortunately the documentation available. It seems
	like most of the documentation on the net about the internal layout of
	Ext2 was written to complement the Linux sources rather than be a
	complete document by themselves.
  </P
><P
>	Hopefully this document will fix this problem, may it be of help to as
	many of you as possible.
  </P
><P
>	<I
CLASS="EMPHASIS"
>Unless otherwise stated, all values  are  stored  in  little
	endian byte order.</I
>
  </P
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="DISK-ORGANISATION"
>Chapter 1. Disk Organisation</A
></H1
><P
>	The first aspect of using the Second Extended File System one  has  to
	grasp is that all  the  meta-data  structures  size  are  based  on  a
	<SPAN
CLASS="QUOTE"
>"block"</SPAN
> size rather than a <SPAN
CLASS="QUOTE"
>"sector"</SPAN
> size.  This  block
	size is variable depending on the size of the file system. On a floppy
	disk for example, it is 1KB (2 sectors), while on  a  10GB  partition,
	the block size is normally 4KB or 8KB (8 and 16 sectors respectively).
  </P
><P
>	Each block is further sub-divided into "fragments", but I have yet  to
	see a file system  which  fragment  size  doesn't  match  block  size.
	Although my guts tells me that there must  be  some  folks  out  there
	using different sizes for fragments and blocks.
  </P
><P
>	Except for the superblock, all meta-data structures are resized to fit
	into blocks. This is something to remember when trying  to  mount  any
	other file system  than  one  on  a  floppy.  The  <SPAN
CLASS="QUOTE"
>"Inode  Table
	Block"</SPAN
> for example will contain more entries in a 4KB block than  in
	a 1KB block, so one will have to take that into account when accessing
	this particular structure.
  </P
><P
>	The  next  major  aspect  is  that  the  file  system  is  split  into
	<SPAN
CLASS="QUOTE"
>"block groups"</SPAN
>. While a floppy would contain  only  one  block
	group holding all the blocks of the file system, a hard disk  of  10GB
	could easily be split into 30 of such block  groups;  each  holding  a
	certain quantity of blocks.
  </P
><P
>	At the start of each block  group  are  various  meta-data  structures
	detailing the location  of  the  other,  more  informative,  meta-data
	structures  defining  the  current  file  system  state.   Here's  the
	organisation of an ext2 file system on a floppy:
  </P
><DIV
CLASS="FIGURE"
><A
NAME="AEN37"
></A
><P
><B
>Figure 1-1. floppy disk meta-data layout</B
></P
><PRE
CLASS="PROGRAMLISTING"
>offset   # of blocks description
-------- ----------- -----------
       0           1 boot record
         -- block group 0 --
(1024 bytes)       1 <A
HREF="#SUPERBLOCK"
>superblock</A
>
       2           1 <A
HREF="#GROUP-DESCRIPTOR"
>group descriptors</A
>
       3           1 <A
HREF="#BLOCK-BITMAP"
>block bitmap</A
>
       4           1 <A
HREF="#INODE-BITMAP"
>inode bitmap</A
>
       5          23 <A
HREF="#INODE-TABLE"
>inode table</A
>
      28        1412 <A
HREF="#DATA-BLOCKS"
>data blocks</A
>
  </PRE
></DIV
><P
>	And here's the organisation of a 20MB ext2 file system:
  </P
><DIV
CLASS="FIGURE"
><A
NAME="AEN47"
></A
><P
><B
>Figure 1-2. 20mb partition meta-data layout</B
></P
><PRE
CLASS="PROGRAMLISTING"
>offset   # of blocks description
-------- ----------- -----------
       0           1 boot record
         -- block group 0 --
(1024 bytes)       1 <A
HREF="#SUPERBLOCK"
>superblock</A
>
       2           1 <A
HREF="#GROUP-DESCRIPTOR"
>group descriptors</A
>
       3           1 <A
HREF="#BLOCK-BITMAP"
>block bitmap</A
>
       4           1 <A
HREF="#INODE-BITMAP"
>inode bitmap</A
>
       5         214 <A
HREF="#INODE-TABLE"
>inode table</A
>
     219        7974 <A
HREF="#DATA-BLOCKS"
>data blocks</A
>
         -- block group 1 --
    8193           1 <A
HREF="#SUPERBLOCK"
>superblock</A
> backup
    8194           1 <A
HREF="#GROUP-DESCRIPTOR"
>group descriptors</A
> backup
    8195           1 <A
HREF="#BLOCK-BITMAP"
>block bitmap</A
>
    8196           1 <A
HREF="#INODE-BITMAP"
>inode bitmap</A
>
    8197         214 <A
HREF="#INODE-TABLE"
>inode table</A
>
    8408        7974 <A
HREF="#DATA-BLOCKS"
>data blocks</A
>
         -- block group 2 --
   16385           1 <A
HREF="#BLOCK-BITMAP"
>block bitmap</A
>
   16386           1 <A
HREF="#INODE-BITMAP"
>inode bitmap</A
>
   16387         214 <A
HREF="#INODE-TABLE"
>inode table</A
>
   16601        3879 <A
HREF="#DATA-BLOCKS"
>data blocks</A
>
  </PRE
></DIV
><P
>	The layout on disk is very predictable as long as you know a few basic
	information; block size, blocks per  group,  inodes  per  group.  This
	information  is  all  located  in,  or  can  be  computed  from,   the
	<SPAN
CLASS="STRUCTNAME"
>superblock</SPAN
> structure.
  </P
><P
>	Without  the  <SPAN
CLASS="STRUCTNAME"
>superblock</SPAN
>  information,  the   disk   is
	useless; therefore as soon as enough space is available, one  or  more
	superblock backups will be created on the disk.
  </P
><P
>	The <SPAN
CLASS="STRUCTNAME"
>block bitmap</SPAN
>  and  <SPAN
CLASS="STRUCTNAME"
>inode bitmap</SPAN
>  are
	used to identify which blocks and which inode entries are free to use.
	The <SPAN
CLASS="STRUCTNAME"
>data blocks</SPAN
> is where  the  various  files  will  be
	stored.  Note that a directory is also seen as a file under  Ext2,  we
	will go in more detail about that later on.
  </P
><P
>	<I
CLASS="EMPHASIS"
>While all ext2 implementations try to  be  compatible,  some
	fields in the various structures  have  been  customized  to  fit  the
	requirements of a specific operating system.  Where  such  differences
	are known, they will be indicated in proper time.</I
>
  </P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="SUPERBLOCK"
>1.1. superblock</A
></H1
><P
>	The  <SPAN
CLASS="STRUCTNAME"
>superblock</SPAN
>  is  the  structure  on  an  ext2  disk
	containing  the  very  basic  information  about   the   file   system
	properties.  It is layed out in the following form:
   </P
><DIV
CLASS="FIGURE"
><A
NAME="AEN80"
></A
><P
><B
>Figure 1-3. superblock structure</B
></P
><PRE
CLASS="PROGRAMLISTING"
>offset  size    description
------- ------- -----------
      0       4 <A
HREF="#S-INODES-COUNT"
>s_inodes_count</A
>
      4       4 <A
HREF="#S-BLOCKS-COUNT"
>s_blocks_count</A
>
      8       4 <A
HREF="#S-R-BLOCKS-COUNT"
>s_r_blocks_count</A
>
     12       4 <A
HREF="#S-FREE-BLOCKS-COUNT"
>s_free_blocks_count</A
>
     16       4 <A
HREF="#S-FREE-INODES-COUNT"
>s_free_inodes_count</A
>
     20       4 <A
HREF="#S-FIRST-DATA-BLOCK"
>s_first_data_block</A
>
     24       4 <A
HREF="#S-LOG-BLOCK-SIZE"
>s_log_block_size</A
>
     28       4 <A
HREF="#S-LOG-FRAG-SIZE"
>s_log_frag_size</A
>
     32       4 <A
HREF="#S-BLOCKS-PER-GROUP"
>s_blocks_per_group</A
>
     36       4 <A
HREF="#S-FRAGS-PER-GROUP"
>s_frags_per_group</A
>
     40       4 <A
HREF="#S-INODES-PER-GROUP"
>s_inodes_per_group</A
>
     44       4 <A
HREF="#S-MTIME"
>s_mtime</A
>
     48       4 <A
HREF="#S-WTIME"
>s_wtime</A
>
     52       2 <A
HREF="#S-MNT-COUNT"
>s_mnt_count</A
>
     54       2 <A
HREF="#S-MAX-MNT-COUNT"
>s_max_mnt_count</A
>
     56       2 <A
HREF="#S-MAGIC"
>s_magic</A
>
     58       2 <A
HREF="#S-STATE"
>s_state</A
>
     60       2 <A
HREF="#S-ERRORS"
>s_errors</A
>
     62       2 <A
HREF="#S-MINOR-REV-LEVEL"
>s_minor_rev_level</A
>
     64       4 <A
HREF="#S-LASTCHECK"
>s_lastcheck</A
>
     68       4 <A
HREF="#S-CHECKINTERVAL"
>s_checkinterval</A
>
     72       4 <A
HREF="#S-CREATOR-OS"
>s_creator_os</A
>
     76       4 <A
HREF="#S-REV-LEVEL"
>s_rev_level</A
>
     80       2 <A
HREF="#S-DEF-RESUID"
>s_def_resuid</A
>
     82       2 <A
HREF="#S-DEF-RESGID"
>s_def_resgid</A
>
   -- EXT2_DYNAMIC_REV Specific --
     84       4 <A
HREF="#S-FIRST-INO"
>s_first_ino</A
>
     88       2 <A
HREF="#S-INODE-SIZE"
>s_inode_size</A
>
     90       2 <A
HREF="#S-BLOCK-GROUP-NR"
>s_block_group_nr</A
>
     92       4 <A
HREF="#S-FEATURE-COMPAT"
>s_feature_compat</A
>
     96       4 <A
HREF="#S-FEATURE-INCOMPAT"
>s_feature_incompat</A
>
    100       4 <A
HREF="#S-FEATURE-RO-COMPAT"
>s_feature_ro_compat</A
>
    104      16 <A
HREF="#S-UUID"
>s_uuid</A
>
    120      16 <A
HREF="#S-VOLUME-NAME"
>s_volume_name</A
>
    136      64 <A
HREF="#S-LAST-MOUNTED"
>s_last_mounted</A
>
    200       4 <A
HREF="#S-ALGO-BITMAP"
>s_algo_bitmap</A
>
   -- Performance Hints         --
    204       1 s_prealloc_blocks
    205       1 s_prealloc_dir_blocks
    206       2 - (alignment)
   -- Journaling Support        --
    208      16 s_journal_uuid
    224       4 s_journal_inum
    228       4 s_journal_dev
    232       4 s_last_orphan
   -- Unused                    --
    236     788 - (padding)
   </PRE
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-INODES-COUNT"
>1.1.1. s_inodes_count</A
></H2
><P
>	32bit value indicating the total number of inodes, both used and free,
	in the file system.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-BLOCKS-COUNT"
>1.1.2. s_blocks_count</A
></H2
><P
>	32bit value indicating the total number of blocks, both used and free,
	in the file system.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-R-BLOCKS-COUNT"
>1.1.3. s_r_blocks_count</A
></H2
><P
>	32bit value indicating the total number of  blocks  reserved  for  the
	usage of the super user.  This is most useful if  for  some  reason  a
	user, maliciously or not, fill the file system to capacity; the  super
	user will have this specified amount of free blocks at his disposal so
	he can edit and save configuration files.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-FREE-BLOCKS-COUNT"
>1.1.4. s_free_blocks_count</A
></H2
><P
>	32bit value indicating the total number of free blocks, including  the
	number of reserved blocks (see
	<A
HREF="#S-R-BLOCKS-COUNT"
>s_r_blocks_count</A
>).  This is a  sum
	of all free blocks of all the block groups.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-FREE-INODES-COUNT"
>1.1.5. s_free_inodes_count</A
></H2
><P
>	32bit value indicating the total number of free inodes.  This is a sum
	of all free inodes of all the block groups.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-FIRST-DATA-BLOCK"
>1.1.6. s_first_data_block</A
></H2
><P
>	32bit value identifying the first data block, in other word the id  of
	the block containing the <SPAN
CLASS="STRUCTNAME"
>superblock</SPAN
> structure.
    </P
><P
>	Note that this value is always 0 for file systems with  a  block  size
	larger than 1KB, and always 1 for file systems with a  block  size  of
	1KB.  The <SPAN
CLASS="STRUCTNAME"
>superblock</SPAN
> is <I
CLASS="EMPHASIS"
>always</I
> starting at
	the 1024th byte of the disk, which normally happens to  be  the  first
	byte of the 3rd sector.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-LOG-BLOCK-SIZE"
>1.1.7. s_log_block_size</A
></H2
><P
>	The block size is computed using this 32bit value  as  the  number  of
	bits to shift left the value 1024.  This value may only be positive.
    </P
><PRE
CLASS="PROGRAMLISTING"
>block size = 1024 &lt;&lt; s_log_block_size;
    </PRE
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-LOG-FRAG-SIZE"
>1.1.8. s_log_frag_size</A
></H2
><P
>	The fragment size is computed using this 32bit value as the number  of
	bits to shift left the value 1024.  Note that a negative  value  would
	shift the bit right rather than left.
    </P
><PRE
CLASS="PROGRAMLISTING"
>if( positive )
  fragmnet size = 1024 &lt;&lt; s_log_frag_size;
else
  framgnet size = 1024 &gt;&gt; -s_log_frag_size;
    </PRE
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-BLOCKS-PER-GROUP"
>1.1.9. s_blocks_per_group</A
></H2
><P
>	32bit value indicating the total number  of  blocks  per  group.  This
	value in combination with
	<A
HREF="#S-FIRST-DATA-BLOCK"
>s_first_data_block</A
> can  be  used
	to determine the block groups boundaries.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-FRAGS-PER-GROUP"
>1.1.10. s_frags_per_group</A
></H2
><P
>	32bit value indicating the total number of fragments per group.  It is
	also used to determine the size of the <SPAN
CLASS="STRUCTNAME"
>block bitmap</SPAN
>  of
	each block group.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-INODES-PER-GROUP"
>1.1.11. s_inodes_per_group</A
></H2
><P
>	32bit value indicating the total number of inodes per group.  This  is
	also used to determine the size of the <SPAN
CLASS="STRUCTNAME"
>inode bitmap</SPAN
>  of
	each block group.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-MTIME"
>1.1.12. s_mtime</A
></H2
><P
>	Unix time, as defined by POSIX, of the last time the file  system  was
	mounted.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-WTIME"
>1.1.13. s_wtime</A
></H2
><P
>	Unix time, as defined by POSIX, of the last write access to  the  file
	system.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-MNT-COUNT"
>1.1.14. s_mnt_count</A
></H2
><P
>	32bit value indicating how many  time  the  file  system  was  mounted
	since the last time it was fully verified.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-MAX-MNT-COUNT"
>1.1.15. s_max_mnt_count</A
></H2
><P
>	32bit value indicating the maximum  number  of  times  that  the  file
	system may be mounted before a full check is performed.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-MAGIC"
>1.1.16. s_magic</A
></H2
><P
>	16bit value  identifying  the  file  system  as  Ext2.  The  value  is
	currently fixed to <TT
CLASS="CONSTANT"
>0xEF53</TT
>.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-STATE"
>1.1.17. s_state</A
></H2
><P
>	16bit value indicating the file system state.  When the file system is
	mounted, this state is set  to  <TT
CLASS="CONSTANT"
>EXT2_ERROR_FS</TT
>.  When  the
	file  system  is  not  yet  mounted,  this   value   may   be   either
	<TT
CLASS="CONSTANT"
>EXT2_VALID_FS</TT
> or <TT
CLASS="CONSTANT"
>EXT2_ERROR_FS</TT
> in the  event
	the file system was not cleanly unmounted.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-ERRORS"
>1.1.18. s_errors</A
></H2
><P
>	16bit value indicating what the file system driver should do  when  an
	error is detected.  The following values have been defined:
    </P
><DIV
CLASS="TABLE"
><A
NAME="EXT2-ERRORS"
></A
><P
><B
>Table 1-1. EXT2_ERRORS values</B
></P
><TABLE
BORDER="0"
WIDTH="100%"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_ERRORS_CONTINUE</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>1</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>continue as if nothing happened</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_ERRORS_RO</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>2</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>remount read-only</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_ERRORS_PANIC</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>3</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>cause a kernel panic</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_ERRORS_DEFAULT</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>varies</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>as of revision 0.5, this is the same as EXT2_ERRORS_CONTINUE</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-MINOR-REV-LEVEL"
>1.1.19. s_minor_rev_level</A
></H2
><P
>	16bit value identifying the minor revision level within its
	<A
HREF="#S-REV-LEVEL"
>revision level</A
>.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-LASTCHECK"
>1.1.20. s_lastcheck</A
></H2
><P
>	Unix time, as defined by POSIX, of the last file system check.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-CHECKINTERVAL"
>1.1.21. s_checkinterval</A
></H2
><P
>	Maximum Unix time interval, as defined by POSIX, allowed between file
	system checks.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-CREATOR-OS"
>1.1.22. s_creator_os</A
></H2
><P
>	32bit identifier of the os that created the file system.  Defined
	values are:
    </P
><DIV
CLASS="TABLE"
><A
NAME="EXT2-OS"
></A
><P
><B
>Table 1-2. EXT2_OS values</B
></P
><TABLE
BORDER="0"
WIDTH="100%"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_OS_LINUX</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>Linux</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_OS_HURD</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>1</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>Hurd</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_OS_MASIX</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>2</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>MASIX</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_OS_FREEBSD</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>3</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>FreeBSD</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_OS_LITES4</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>4</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>Lites</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-REV-LEVEL"
>1.1.23. s_rev_level</A
></H2
><P
>	32bit revision level value.  There are currently only 2 values defined:
    </P
><DIV
CLASS="TABLE"
><A
NAME="AEN252"
></A
><P
><B
>Table 1-3. EXT2 revisions</B
></P
><TABLE
BORDER="0"
WIDTH="100%"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_GOOD_OLD_REV</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>original format</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_DYNAMIC_REV</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>1</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>V2 format with dynamic inode sizes</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-DEF-RESUID"
>1.1.24. s_def_resuid</A
></H2
><P
>	16bit value used as the default user id for reserved blocks.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-DEF-RESGID"
>1.1.25. s_def_resgid</A
></H2
><P
>	16bit value used as the default group id for reserved blocks.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-FIRST-INO"
>1.1.26. s_first_ino</A
></H2
><P
>	32bit value used as index to the  first  inode  useable  for  standard
	files.  In  the  non-dynamic  file   system   revisions,   the   first
	non-reserved inode was fixed to <TT
CLASS="CONSTANT"
>11</TT
>. With the introduction
	the dynamic revision of the file system it is now possible  to  modify
	this value.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-INODE-SIZE"
>1.1.27. s_inode_size</A
></H2
><P
>	16bit value indicating the size of the inode structure. In
	non-dynamic file system revisions this value is assumed to be
	<TT
CLASS="CONSTANT"
>128</TT
>.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-BLOCK-GROUP-NR"
>1.1.28. s_block_group_nr</A
></H2
><P
>	16bit value used to indicate the block group number hosting this
	superblock structure.  This can be used to rebuild the file system
	from any superblock backup.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-FEATURE-COMPAT"
>1.1.29. s_feature_compat</A
></H2
><P
>	32bit bitmask of compatible features.  The file system implementation
	is free to support them or not without risk of damaging the meta-data.
	(more information will be added soon)
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-FEATURE-INCOMPAT"
>1.1.30. s_feature_incompat</A
></H2
><P
>	32bit bitmask of incompatible features.  The file system
	implementation should refuse to mount the file system if any of
	the indicated feature is unsupported.
	(more information will be added soon)
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-FEATURE-RO-COMPAT"
>1.1.31. s_feature_ro_compat</A
></H2
><P
>	32bit bitmask of <SPAN
CLASS="QUOTE"
>"read-only"</SPAN
> features.  The file system
	implementation should mount as read-only if any of the indicated
	feature is unsupported.
	(more information will be added soon)
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-UUID"
>1.1.32. s_uuid</A
></H2
><P
>	128bit value used as the volume id.  This should, as much as possible,
	be unique for each file system formatted.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-VOLUME-NAME"
>1.1.33. s_volume_name</A
></H2
><P
>	16 bytes volume name, mostly unusued.  A valid volume name would consist
	of only ISO-Latin-1 characters and be 0 terminated.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-LAST-MOUNTED"
>1.1.34. s_last_mounted</A
></H2
><P
>	64 bytes directory path where the file system was last mounted.  While
	not normally used, it could serve for auto-finding the mountpoint when
	not indicated on the command line. Again the path should be zero
	terminated for compatibility reasons.  Valid path is constructed from
	ISO-Latin-1 characters.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="S-ALGO-BITMAP"
>1.1.35. s_algo_bitmap</A
></H2
><P
>	32bit value used by compression algorithms to determine the methods
	used. (I do not have any more detail about this field, if you do please
	do send me all the information you have, thanks).
    </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="GROUP-DESCRIPTOR"
>1.2. Group Descriptor</A
></H1
><P
>	The group descriptors is an array of the <SPAN
CLASS="STRUCTNAME"
>group_desc</SPAN
>
	structure, each describing a <SPAN
CLASS="QUOTE"
>"block group"</SPAN
>, giving the
	location of its inode table, blocks and inodes bitmaps, and some
	other useful informations.
   </P
><P
>	The group descriptors are located on the first block following the
	block containing the superblock structure. Here's what one of the
	group descriptor looks like:
   </P
><DIV
CLASS="FIGURE"
><A
NAME="AEN312"
></A
><P
><B
>Figure 1-4. group_desc structure</B
></P
><PRE
CLASS="PROGRAMLISTING"
>offset  size    description
------- ------- -----------
      0       4 <A
HREF="#BG-BLOCK-BITMAP"
>bg_block_bitmap</A
>
      4       4 <A
HREF="#BG-INODE-BITMAP"
>bg_inode_bitmap</A
>
      8       4 <A
HREF="#BG-INODE-TABLE"
>bg_inode_table</A
>
     12       2 <A
HREF="#BG-FREE-BLOCKS-COUNT"
>bg_free_blocks_count</A
>
     14       2 <A
HREF="#BG-FREE-INODES-COUNT"
>bg_free_inodes_count</A
>
     16       2 <A
HREF="#BG-USED-DIRS-COUNT"
>bg_used_dirs_count</A
>
     18       2 <A
HREF="#BG-PAD"
>bg_pad</A
>
     20      12 <A
HREF="#BG-RESERVED"
>bg_reserved</A
>
   </PRE
></DIV
><P
>	For each group in the file system, such a <SPAN
CLASS="STRUCTNAME"
>group_desc</SPAN
> is
	created.  Each represent a single <SPAN
CLASS="QUOTE"
>"block group"</SPAN
> within the
	file system and the information within any one of them is pertinent
	only to the group it is describing.  Every <SPAN
CLASS="QUOTE"
>"Group Descriptor
	Table"</SPAN
> contains all the information about all the groups.
   </P
><P
>	All indicated <SPAN
CLASS="QUOTE"
>"block id"</SPAN
> are absolute.
   </P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="BG-BLOCK-BITMAP"
>1.2.1. bg_block_bitmap</A
></H2
><P
>	32bit block id of the first block of the
	<SPAN
CLASS="QUOTE"
>"<A
HREF="#BLOCK-BITMAP"
>block bitmap</A
>"</SPAN
>
	for the group represented.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="BG-INODE-BITMAP"
>1.2.2. bg_inode_bitmap</A
></H2
><P
>	32bit block id of the first block of the
	<SPAN
CLASS="QUOTE"
>"<A
HREF="#INODE-BITMAP"
>inode bitmap</A
>"</SPAN
>
	for the group represented.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="BG-INODE-TABLE"
>1.2.3. bg_inode_table</A
></H2
><P
>	32bit block id of the first block of the
	<SPAN
CLASS="QUOTE"
>"<A
HREF="#INODE-TABLE"
>inode table</A
>"</SPAN
>
	for the group represented.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="BG-FREE-BLOCKS-COUNT"
>1.2.4. bg_free_blocks_count</A
></H2
><P
>	16bit value indicating the total number of free blocks for
	the represented group.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="BG-FREE-INODES-COUNT"
>1.2.5. bg_free_inodes_count</A
></H2
><P
>	16bit value indicating the total number of free inodes for
	the represented group.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="BG-USED-DIRS-COUNT"
>1.2.6. bg_used_dirs_count</A
></H2
><P
>	16bit value indicating the number of inodes allocated to
	directories for the represented group.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="BG-PAD"
>1.2.7. bg_pad</A
></H2
><P
>	16bit value used for padding the structure on a 32bit boundary.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="BG-RESERVED"
>1.2.8. bg_reserved</A
></H2
><P
>	3 successive 32bit values reserved for future implementations.
    </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="BLOCK-BITMAP"
>1.3. Block Bitmap</A
></H1
><P
>	The <SPAN
CLASS="QUOTE"
>"Block Bitmap"</SPAN
> is normally located at the first block, or second
	block if a superblock backup is present, of the block group.
	Its official location can be determined by reading the
	<SPAN
CLASS="QUOTE"
>"<A
HREF="#BG-BLOCK-BITMAP"
>bg_block_bitmap</A
>"</SPAN
>
	in its associated <A
HREF="#GROUP-DESCRIPTOR"
>group descriptor</A
>.
   </P
><P
>	Each bit represent the current state of a block within that group,
	where 1 means <SPAN
CLASS="QUOTE"
>"used"</SPAN
> and 0 <SPAN
CLASS="QUOTE"
>"free/available"</SPAN
>. The
	first block of this block group is represented by bit 0 of byte 0,
	the second by bit 1 of byte 0.  The 8th block is represented by bit 7
	(most significant bit) of byte 0 while the 9th block is represented by
	bit 0 (least significant bit) of byte 1.
   </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="INODE-BITMAP"
>1.4. Inode Bitmap</A
></H1
><P
>	The <SPAN
CLASS="QUOTE"
>"Inode Bitmap"</SPAN
> works in a similar way as the
	<SPAN
CLASS="QUOTE"
>"<A
HREF="#BLOCK-BITMAP"
>Block Bitmap</A
>"</SPAN
>,
	difference being in each bit representing an inode in the
	<SPAN
CLASS="QUOTE"
>"<A
HREF="#INODE-TABLE"
>Inode Table</A
>"</SPAN
> rather
	than a block.
   </P
><P
>	There is one inode bitmap per group and its location may be
	determined by reading the
	<SPAN
CLASS="QUOTE"
>"<A
HREF="#BG-INODE-BITMAP"
>bg_inode_bitmap</A
>"</SPAN
>
	in its associated <A
HREF="#GROUP-DESCRIPTOR"
>group descriptor</A
>.
   </P
><P
>   	When the inode table is created, all the reserved inodes are marked
	as used.  For the <SPAN
CLASS="QUOTE"
>"Good Old Revision"</SPAN
> this means the first
	11 bits of the inode bitmap.
   </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="INODE-TABLE"
>1.5. Inode Table</A
></H1
><P
>	The <SPAN
CLASS="QUOTE"
>"Inode Table"</SPAN
> is used to keep track of every file; their
	location, size, type and access rights are all stored in inodes.  The
	filename is not stored in there though, within the inode tables all
	files are refenced by their inode number.
   </P
><P
>	There is one inode table per group and it can be located by reading the
	<SPAN
CLASS="QUOTE"
>"<A
HREF="#BG-INODE-TABLE"
>bg_inode_table</A
>"</SPAN
>
	in its associated <A
HREF="#GROUP-DESCRIPTOR"
>group descriptor</A
>.
	There are <A
HREF="#S-INODES-PER-GROUP"
>s_inodes_per_group</A
>
	inodes per table.
   </P
><P
>	Each inode contain the information about a single physical file on the
	system.  A file can be a directory, a socket, a buffer, character or
	block device, symbolic link or a regular file.  So an inode can be
	seen as a block of information related to an entity, describing its
	location on disk, its size and its owner.  An inode looks like this:
   </P
><DIV
CLASS="FIGURE"
><A
NAME="INODE"
></A
><P
><B
>Figure 1-5. inode structure</B
></P
><PRE
CLASS="PROGRAMLISTING"
>offset  size    description
------- ------- -----------
      0       2 <A
HREF="#I-MODE"
>i_mode</A
>
      2       2 <A
HREF="#I-UID"
>i_uid</A
>
      4       4 <A
HREF="#I-SIZE"
>i_size</A
>
      8       4 <A
HREF="#I-ATIME"
>i_atime</A
>
     12       4 <A
HREF="#I-CTIME"
>i_ctime</A
>
     16       4 <A
HREF="#I-MTIME"
>i_mtime</A
>
     20       4 <A
HREF="#I-DTIME"
>i_dtime</A
>
     24       2 <A
HREF="#I-GID"
>i_gid</A
>
     26       2 <A
HREF="#I-LINKS-COUNT"
>i_links_count</A
>
     28       4 <A
HREF="#I-BLOCKS"
>i_blocks</A
>
     32       4 <A
HREF="#I-FLAGS"
>i_flags</A
>
     36       4 <A
HREF="#I-OSD1"
>i_osd1</A
>
     40  15 x 4 <A
HREF="#I-BLOCK"
>i_block</A
>
    100       4 <A
HREF="#I-GENERATION"
>i_generation</A
>
    104       4 <A
HREF="#I-FILE-ACL"
>i_file_acl</A
>
    108       4 <A
HREF="#I-DIR-ACL"
>i_dir_acl</A
>
    112       4 <A
HREF="#I-FADDR"
>i_faddr</A
>
    116      12 <A
HREF="#I-OSD2"
>i_osd2</A
>
   </PRE
></DIV
><P
>	The first few entries of the inode tables are reserved.  In the
	EXT2_GOOD_OLD_REV there are 11 entries reserved while in the newer
	EXT2_DYNAMIC_REV the number of reserved inodes entries is specified
	in the <A
HREF="#S-FIRST-INO"
>s_first_ino</A
> of the superblock
	structure.  Here's a listing of the known reserved inode entries:
   </P
><DIV
CLASS="TABLE"
><A
NAME="AEN416"
></A
><P
><B
>Table 1-4. EXT2_*_INO values</B
></P
><TABLE
BORDER="0"
WIDTH="100%"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_BAD_INO</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x01</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>bad blocks inode</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_ROOT_INO</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x02</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>root directory inode</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_ACL_IDX_INO</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x03</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>ACL index inode (deprecated?)</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_ACL_DATA_INO</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x04</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>ACL data inode (deprecated?)</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_BOOT_LOADER_INO</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x05</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>boot loader inode</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_UNDEL_DIR_INO</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x06</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>undelete directory inode</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="I-MODE"
>1.5.1. i_mode</A
></H2
><P
>	16bit value used to indicate the format of the described file and the
	access rights.  Here are the possible values, which can be combined
	in various ways:
    </P
><DIV
CLASS="TABLE"
><A
NAME="AEN450"
></A
><P
><B
>Table 1-5. EXT2_S_I values</B
></P
><TABLE
BORDER="0"
WIDTH="100%"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
COLSPAN="3"
ALIGN="CENTER"
VALIGN="TOP"
>-- file format --</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_IFMT</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0xF000</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>format mask</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_IFSOCK</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0xC000</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>socket</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_IFLNK</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0xA000</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>symbolic link</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_IFREG</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x8000</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>regular file</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_IFBLK</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x6000</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>block device</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_IFDIR</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x4000</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>directory</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_IFCHR</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x2000</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>character device</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_IFIFO</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x1000</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>fifo</TD
></TR
><TR
><TD
COLSPAN="3"
ALIGN="CENTER"
VALIGN="TOP"
>-- access rights --</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_ISUID</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x0800</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>SUID</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_ISGID</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x0400</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>SGID</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_ISVTX</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x0200</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>sticky bit</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_IRWXU</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x01C0</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>user access rights  mask</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_IRUSR</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x0100</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>read</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_IWUSR</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x0080</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>write</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_IXUSR</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x0040</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>execute</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_IRWXG</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x0038</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>group access rights mask</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_IRGRP</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x0020</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>read</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_IWGRP</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x0010</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>write</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_IXGRP</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x0008</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>execute</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_IRWXO</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x0007</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>others access rights mask</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_IROTH</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x0004</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>read</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_IWOTH</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x0002</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>write</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_S_IXOTH</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x0001</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>execute</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="I-UID"
>1.5.2. i_uid</A
></H2
><P
>	16bit user id associated with the file.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="I-SIZE"
>1.5.3. i_size</A
></H2
><P
>	32bit value indicating the size of the file in bytes.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="I-ATIME"
>1.5.4. i_atime</A
></H2
><P
>	32bit value representing the number of seconds since january 1st 1970
	of the last time this file was accessed.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="I-CTIME"
>1.5.5. i_ctime</A
></H2
><P
>	32bit value representing the number of seconds since january 1st 1970
	when the file was created.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="I-MTIME"
>1.5.6. i_mtime</A
></H2
><P
>	32bit value representing the number of seconds since january 1st 1970
	of the last time this file was modified.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="I-DTIME"
>1.5.7. i_dtime</A
></H2
><P
>	32bit value representing the number of seconds since january 1st 1970
	when the file was deleted.  It is important that unless the file is
	deleted that this value is always 0.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="I-GID"
>1.5.8. i_gid</A
></H2
><P
>	16bit value of the group having access to this file.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="I-LINKS-COUNT"
>1.5.9. i_links_count</A
></H2
><P
>	16bit value indicating how many times this particular inode is linked (referred to).
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="I-BLOCKS"
>1.5.10. i_blocks</A
></H2
><P
>        32bit value indicating the amount of blocks reserved for the
	associated file data.  This includes both currently in used and
	currently reserved blocks in case the file grows in size.
    </P
><P
>	A point worth of note is that this value indicate the number of
	512 bytes block and not the number of blocks of the size indicated
	in the superblock.  So if a file uses only 1 file system block and
	is 1024 bytes big, its .i_blocks value will be 2.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="I-FLAGS"
>1.5.11. i_flags</A
></H2
><P
>        32bit value indicating how the ext2 implementation should behave when accessing the data for this inode. (See the
	    <A
HREF="#BEHAVIOUR-FLAGS"
>Behaviour flags</A
> section.)
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="I-OSD1"
>1.5.12. i_osd1</A
></H2
><P
>        32bit OS dependant value.
    </P
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="I-OSD1-HURD"
>1.5.12.1. Hurd</A
></H3
><P
>        32bit value labeled as <SPAN
CLASS="QUOTE"
>"translator"</SPAN
>.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="I-OSD1-LINUX"
>1.5.12.2. Linux</A
></H3
><P
>        32bit value currently reserved.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="I-OSD1-MASIX"
>1.5.12.3. Masix</A
></H3
><P
>        32bit value currently reserved.
     </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="I-BLOCK"
>1.5.13. i_block</A
></H2
><P
>        Array used to locate the blocks the particular file is stored on. Each
	entry is a 32bit block number. The first 12 entries in this array are
	block numbers, which can be used to fetch the first 12 blocks
	associated with the file.
    </P
><P
>        The 13th entry is an indirect block number. Which means that at the
	specified data block, you will find an array of direct block numbers.
    </P
><P
>        The 14th entry is an bi-indirect block number. Which means that at the
	specified data block, you will find an array of indirect block number,
	which in turn contains an array of block numbers that can be accessed
	directly.
    </P
><P
>        The 15th entry is an tri-indirect block number. It is a block number
        which contains an array of bi-indirect block number, etc.
    </P
><P
>        Each indirect/bi-indirect/tri-indirect block array contains as many
	entries of 32bit block numbers as possible (to fill one entire block).
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="I-GENERATION"
>1.5.14. i_generation</A
></H2
><P
>        32bit value used to indicate the file version (used by NFS).
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="I-FILE-ACL"
>1.5.15. i_file_acl</A
></H2
><P
>	32bit value indicating the block number containing the extended
	attributes. In previous revisions this value was always 0.
    </P
><P
>	A general description of ACL for Digital UNIX can be found at
	this url for the moment: http://www.tru64unix.compaq.com/docs/base_doc/DOCUMENTATION/HTML/AA-Q0R2D-TET1_html/sec.c27.html
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="I-DIR-ACL"
>1.5.16. i_dir_acl</A
></H2
><P
>	32bit value used to indicate the <SPAN
CLASS="QUOTE"
>"high size"</SPAN
> of the file. In
	previous revisions this value was always 0.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="I-FADDR"
>1.5.17. i_faddr</A
></H2
><P
>        32bit value indicating the location of the last file fragment.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="I-OSD2"
>1.5.18. i_osd2</A
></H2
><P
>        96bit OS dependant structure.
    </P
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="I-OSD2-HURD"
>1.5.18.1. Hurd</A
></H3
><DIV
CLASS="FIGURE"
><A
NAME="AEN625"
></A
><P
><B
>Figure 1-6. inode osd2 structure: Hurd</B
></P
><PRE
CLASS="PROGRAMLISTING"
>offset  size    description
------- ------- -----------
      0       1 <A
HREF="#H-I-FRAG"
>h_i_frag</A
>
      1       1 <A
HREF="#H-I-FSIZE"
>h_i_fsize</A
>
      2       2 <A
HREF="#H-I-MODE-HIGH"
>h_i_mode_high</A
>
      4       2 <A
HREF="#H-I-UID-HIGH"
>h_i_uid_high</A
>
      6       2 <A
HREF="#H-I-GID-HIGH"
>h_i_gid_high</A
>
      8       4 <A
HREF="#H-I-AUTHOR"
>h_i_author</A
>
     </PRE
></DIV
><DIV
CLASS="SECT4"
><HR><H4
CLASS="SECT4"
><A
NAME="H-I-FRAG"
>1.5.18.1.1. h_i_frag</A
></H4
><P
>	8bit fragment number.
      </P
></DIV
><DIV
CLASS="SECT4"
><HR><H4
CLASS="SECT4"
><A
NAME="H-I-FSIZE"
>1.5.18.1.2. h_i_fsize</A
></H4
><P
>	8bit fragment size.
      </P
></DIV
><DIV
CLASS="SECT4"
><HR><H4
CLASS="SECT4"
><A
NAME="H-I-MODE-HIGH"
>1.5.18.1.3. h_i_mode_high</A
></H4
><P
>      </P
></DIV
><DIV
CLASS="SECT4"
><HR><H4
CLASS="SECT4"
><A
NAME="H-I-UID-HIGH"
>1.5.18.1.4. h_i_uid_high</A
></H4
><P
>	High 16bit of <A
HREF="#I-UID"
>user id</A
>.
      </P
></DIV
><DIV
CLASS="SECT4"
><HR><H4
CLASS="SECT4"
><A
NAME="H-I-GID-HIGH"
>1.5.18.1.5. h_i_gid_high</A
></H4
><P
>	High 16bit of <A
HREF="#I-GID"
>group id</A
>.
      </P
></DIV
><DIV
CLASS="SECT4"
><HR><H4
CLASS="SECT4"
><A
NAME="H-I-AUTHOR"
>1.5.18.1.6. h_i_author</A
></H4
><P
>      </P
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="I-OSD2-LINUX"
>1.5.18.2. Linux</A
></H3
><DIV
CLASS="FIGURE"
><A
NAME="AEN656"
></A
><P
><B
>Figure 1-7. inode osd2 structure: Linux</B
></P
><PRE
CLASS="PROGRAMLISTING"
>offset  size    description
------- ------- -----------
      0       1 <A
HREF="#L-I-FRAG"
>l_i_frag</A
>
      1       1 <A
HREF="#L-I-FSIZE"
>l_i_fsize</A
>
      2       2 reserved
      4       2 <A
HREF="#L-I-UID-HIGH"
>l_i_uid_high</A
>
      6       2 <A
HREF="#L-I-GID-HIGH"
>l_i_gid_high</A
>
      8       4 reserved
     </PRE
></DIV
><DIV
CLASS="SECT4"
><HR><H4
CLASS="SECT4"
><A
NAME="L-I-FRAG"
>1.5.18.2.1. l_i_frag</A
></H4
><P
>	8bit fragment number.
      </P
></DIV
><DIV
CLASS="SECT4"
><HR><H4
CLASS="SECT4"
><A
NAME="L-I-FSIZE"
>1.5.18.2.2. l_i_fsize</A
></H4
><P
>	8bit fragment size.
      </P
></DIV
><DIV
CLASS="SECT4"
><HR><H4
CLASS="SECT4"
><A
NAME="L-I-UID-HIGH"
>1.5.18.2.3. l_i_uid_high</A
></H4
><P
>	High 16bit of <A
HREF="#I-UID"
>user id</A
>.
      </P
></DIV
><DIV
CLASS="SECT4"
><HR><H4
CLASS="SECT4"
><A
NAME="L-I-GID-HIGH"
>1.5.18.2.4. l_i_gid_high</A
></H4
><P
>	High 16bit of <A
HREF="#I-GID"
>group id</A
>.
      </P
></DIV
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="I-OSD2-MASIX"
>1.5.18.3. Masix</A
></H3
><DIV
CLASS="FIGURE"
><A
NAME="AEN679"
></A
><P
><B
>Figure 1-8. inode osd2 structure: Masix</B
></P
><PRE
CLASS="PROGRAMLISTING"
>offset  size    description
------- ------- -----------
      0       1 <A
HREF="#M-I-FRAG"
>m_i_frag</A
>
      1       1 <A
HREF="#M-I-FSIZE"
>m_i_fsize</A
>
      2      10 reserved
     </PRE
></DIV
><DIV
CLASS="SECT4"
><HR><H4
CLASS="SECT4"
><A
NAME="M-I-FRAG"
>1.5.18.3.1. m_i_frag</A
></H4
><P
>	8bit fragment number.
      </P
></DIV
><DIV
CLASS="SECT4"
><HR><H4
CLASS="SECT4"
><A
NAME="M-I-FSIZE"
>1.5.18.3.2. m_i_fsize</A
></H4
><P
>	8bit fragment size.
      </P
></DIV
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="DATA-BLOCKS"
>1.6. Data Blocks</A
></H1
><P
>	Data blocks are used to store the various files' content, including
	directory listing, extended attributes, symbolic links, etc.
   </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="DIRECTORY"
>Chapter 2. Directory Structure</A
></H1
><P
>	Directories are stored as files and can be identified as such by
	looking up the <A
HREF="#I-MODE"
><TT
CLASS="STRUCTFIELD"
><I
>ext2_inode.i_mode</I
></TT
></A
>
	file format bits for the <TT
CLASS="CONSTANT"
>EXT2_S_IFDIR</TT
> value.
  </P
><P
>	The root directory is always the second entry of the inode table
	(<TT
CLASS="CONSTANT"
>EXT2_ROOT_INO</TT
> is of value 2).  Any subdirectory from there
	can be located by looking at the content of the root directory file.
  </P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="IFDIR"
>2.1. Directory File Format</A
></H1
><DIV
CLASS="FIGURE"
><A
NAME="AEN703"
></A
><P
><B
>Figure 2-1. directory entry</B
></P
><PRE
CLASS="PROGRAMLISTING"
>offset  size    description
------- ------- -----------
      0       4 <A
HREF="#IFDIR-INODE"
>inode</A
>
      4       2 <A
HREF="#IFDIR-REC-LEN"
>rec_len</A
>
      6       1 <A
HREF="#IFDIR-NAME-LEN"
>name_len</A
>
      7       1 <A
HREF="#IFDIR-FILE-TYPE"
>file_type</A
>
      8     ... <A
HREF="#IFDIR-NAME"
>name</A
>
   </PRE
></DIV
><P
>	Earlier implementations of Ext2 used a 16bit <TT
CLASS="STRUCTFIELD"
><I
>name_len</I
></TT
>, but
	since this value is stored in Intel (little-endian) byte order and most implementation
	restricted filenames to maximum 255 characters, allowing a byte to be recycled.
   </P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="IFDIR-INODE"
>2.1.1. inode</A
></H2
><P
>	32bit inode number of the file entry.  A value of 0 indicate that the entry
	is not used.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="IFDIR-REC-LEN"
>2.1.2. rec_len</A
></H2
><P
>	16bit unsigned displacement to the next directory entry from the start of the
	current directory entry.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="IFDIR-NAME-LEN"
>2.1.3. name_len</A
></H2
><P
>	8bit unsigned value indicating how many characters are contained in the name.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="IFDIR-FILE-TYPE"
>2.1.4. file_type</A
></H2
><P
>	8bit unsigned value used to indicate file type.  As noted, this value may be 0
	in earlier implementations.  Currently defined values are:
    </P
><DIV
CLASS="TABLE"
><A
NAME="AEN725"
></A
><P
><B
>Table 2-1. EXT2_FT values</B
></P
><TABLE
BORDER="0"
WIDTH="100%"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_FT_UNKNOWN</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>&nbsp;</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_FT_REG_FILE</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>1</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>&nbsp;</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_FT_DIR</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>2</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>&nbsp;</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_FT_CHRDEV</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>3</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>&nbsp;</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_FT_BLKDEV</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>4</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>&nbsp;</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_FT_FIFO</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>5</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>&nbsp;</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_FT_SOCK</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>6</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>&nbsp;</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_FT_SYMLINK</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>7</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>&nbsp;</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>EXT2_FT_MAX</TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>8</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>&nbsp;</TD
></TR
></TBODY
></TABLE
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="IFDIR-NAME"
>2.1.5. name</A
></H2
><P
>	Name of the entry.  The allowed character set is the ISO-Latin-1.
    </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="DIR-SAMPLE"
>2.2. Sample Directory</A
></H1
><P
>	Here's a sample of the home directory of one user on my system:
   </P
><PRE
CLASS="PROGRAMLISTING"
>$ ls -1a /home/eks
.
..
.bash_profile
.bashrc
mbox
public_html
tmp
   </PRE
><P
>	For which the following data representation can be found on the storage device:
   </P
><DIV
CLASS="FIGURE"
><A
NAME="AEN776"
></A
><P
><B
>Figure 2-2. Sample Directory Data Layout</B
></P
><PRE
CLASS="PROGRAMLISTING"
>offset  size    description
------- ------- -----------
      0       4 inode number (783362)
      4       2 record length (9)
      6       1 name length (1)
      7       1 file type (EXT2_FT_DIR)
      8       1 name (.)

      9       4 inode number (1109761)
     13       2 record length (10)
     15       1 name length (2)
     16       1 file type (EXT2_FT_DIR)
     17       2 name (..)

     19       4 inode number (783364)
     23       2 record length (21)
     25       1 name length (13)
     26       1 file type (EXT2_FT_REG_FILE)
     27      13 name (.bash_profile)

     40       4 inode number (783363)
     44       2 record length (15)
     46       1 name length (7)
     47       1 file type (EXT2_FT_REG_FILE)
     48       7 name (.bashrc)

     55       4 inode number (783377)
     59       2 record length (12)
     61       1 name length (4)
     62       1 file type (EXT2_FT_REG_FILE)
     63       4 name (mbox)

     67       4 inode number (783545)
     71       2 record length (19)
     73       1 name length (11)
     74       1 file type (EXT2_FT_DIR)
     75      11 name (public_html)

     86       4 inode number (669354)
     90       2 record length (11)
     92       1 name length (3)
     93       1 file type (EXT2_FT_DIR)
     94       3 name (tmp)

     97       4 inode number (0)
     101      2 record length (3999)
     103      1 name length (0)
     104      1 file type (EXT2_FT_UNKNOWN)
     105      0 name ()
   </PRE
></DIV
><P
>	It should be noted that some implementation will pad directory entries
	to have better performances on the host processor, it is thus important
	to use the <TT
CLASS="STRUCTFIELD"
><I
>record length</I
></TT
> and not the <TT
CLASS="STRUCTFIELD"
><I
>name
	length</I
></TT
> to find the next record.
   </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="INDEXED-DIRECTORY"
>2.3. Indexed Directory Format</A
></H1
><P
>	Using the standard linked list directory format can become very slow
	once the number of files starts growing.  To improve performances in
	such a system, a hashed index was created, which allow to quickly
	locate the particular file searched.
   </P
><P
>	Bit <A
HREF="#EXT2-INDEX-FL"
>EXT2_INDEX_FL</A
> in the
	<A
HREF="#BEHAVIOUR-FLAGS"
>behaviour control flags</A
> is set if
	the indexed directory format is used.
   </P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="CONTRIB-INDEX-STRUCTURE"
>2.3.1. Index Structure</A
></H2
><P
>	The root of the index tree is in the 0th block of the file.  Space is
	reserved for a second level of the index tree in blocks 1 though 511
	(for 4K filesystem blocks).  Directory leaf blocks are appended
	starting at block 512, thus the tail of the directory file looks like a
	normal Ext2 directory and can be processed directly by ext2_readdir. 
	For directories with less than about 90K files there is a hole running
	from block 1 to block 511, so an empty directory has just two blocks in
	it, though its size appears to be about 2 Meg in a directory listing.
    </P
><P
>	So a directory file looks like:
    </P
><PRE
CLASS="PROGRAMLISTING"
>0: Root index block
1: Index block/0
2: Index block/0
...
511: Index block/0
512: Dirent block
513: Dirent block
...
    </PRE
><P
>	Each index block consists of 512 index entries of the form:
    </P
><PRE
CLASS="PROGRAMLISTING"
>	hash, block
    </PRE
><P
>	where hash is a 32 bit hash with a collision flag in its least
	significant bit, and block is the logical block number of an index of
	leaf block, depending on the tree level.
    </P
><P
>	The hash value of the 0th index entry isn't needed because it can
	always be obtained from the level about, so it is used to record the
	count of index entries in an index block.  This gives a nice round
	branching factor of 512, the evenness being a nicety that mainly
	satisfies my need to seek regularity, rather than winning any real
	performance.  (On the other hand, the largeness of the branching factor
	matters a great deal.)
    </P
><P
>	The root index block has the same format as the other index blocks,
	with its first 8 bytes reserved for a small header:
    </P
><PRE
CLASS="PROGRAMLISTING"
>1 byte header length (default: 8)
1 byte index type (default: 0)
1 byte hash version (default:0)
1 byte tree depth (default: 1)
    </PRE
><P
>	The treatment of the header differs slightly in the attached patch.  In
	particular, only a single level of the index tree (the root) is
	implemented here.  This turns out to be sufficient to handle more than
	90,000 entries, so it is enough for today.  When a second level is
	added to the tree, capacity will incease to somewhere around 50
	million entries, and there is nothing preventing the use of n levels,
	should there ever be a reason.  It's doubtfull that a third level
	will ever be required, but if it is, the design provides for it.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="CONTRIB-LOOKUP-ALGORITHM"
>2.3.2. Lookup Algorithm</A
></H2
><P
>	Lookup is straightforword:
    </P
><PRE
CLASS="PROGRAMLISTING"
>- Compute a hash of the name
- Read the index root
- Use binary search (linear in the current code) to find the
  first index or leaf block that could contain the target hash
  (in tree order)
- Repeat the above until the lowest tree level is reached
- Read the leaf directory entry block and do a normal Ext2
  directory block search in it.
- If the name is found, return its directory entry and buffer
- Otherwise, if the collision bit of the next directory entry is
  set, continue searching in the successor block
    </PRE
><P
>	Normally, two logical blocks of the file will need to be accessed, and
	one or two metadata index blocks.  The effect of the metadata index
	blocks can largely be ignored in terms of disk access time since these
	blocks are unlikely to be evicted from cache.  There is some small CPU
	cost that can be addressed by moving the whole directory into the page
	cache.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="CONTRIB-INSERT-ALGORITHM"
>2.3.3. Insert Algorithm</A
></H2
><P
>	Insertion of new entries into the directory is considerably more
	complex than lookup, due to the need to split leaf blocks when they
	become full, and to satisfy the conditions that allow hash key
	collisions to be handled reliably and efficiently.  I'll just summarize
	here:
    </P
><PRE
CLASS="PROGRAMLISTING"
>- Probe the index as for lookup
- If the target leaf block is full, split it and note the block
  that will receive the new entry
- Insert the new entry in the leaf block using the normal Ext2
  directory entry insertion code.
    </PRE
><P
>	The details of splitting and hash collision handling are somewhat
	messy, but I will be happy to dwell on them at length if anyone is
	interested.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="CONTRIB-SPLITTING"
>2.3.4. Splitting</A
></H2
><P
>	In brief, when a leaf node fills up and we want to put a new entry into
	it the leaf has to be split, and its share of the hash space has to
	be partitioned.  The most straightforward way to do this is to sort the
	entrys by hash value and split somewhere in the middle of the sorted
	list.  This operation is log(number_of_entries_in_leaf) and is not a
	great cost so long as an efficient sorter is used.  I used Combsort
	for this, although Quicksort would have been just as good in this
	case since average case performance is more important than worst case. 
    </P
><P
>	An alternative approach would be just to guess a median value for the
	hash key, and the partition could be done in linear time, but the
	resulting poorer partitioning of hash key space outweighs the small
	advantage of the linear partition algorithm.  In any event, the number
	of entries needing sorting is bounded by the number that fit in a leaf.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="CONTRIB-KEY-COLLISIONS"
>2.3.5. Key Collisions</A
></H2
><P
>	Some complexity is introduced by the need to handle sequences of hash
	key collisions.  It is desireable to avoid splitting such sequences
	between blocks, so the split point of a block is adjusted with this in
	mind.  But the possibility still remains that if the block fills up
	with identically-hashed entries, the sequence may still have to be
	split.  This situation is flagged by placing a 1 in the low bit of the
	index entry that points at the sucessor block, which is naturally
	interpreted by the index probe as an intermediate value without any
	special coding.  Thus, handling the collision problem imposes no real
	processing overhead, just come extra code and a slight reduction in the
	hash key space.  The hash key space remains  sufficient for any
	conceivable number of directory entries, up into the billions.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="CONTRIB-HASH-FUNCTION"
>2.3.6. Hash Function</A
></H2
><P
>	The exact properties of the hash function critically affect the
	performance of this indexing strategy, as I learned by trying a number
	of poor hash functions, at times intentionally.  A poor hash function
	will result in many collisions or poor partitioning of the hash space. 
	To illustrate why the latter is a problem, consider what happens when a
	block is split such that it covers just a few distinct hash values. 
	The probability of later index entries hashing into the same, small
	hash space is very small.  In practice, once a block is split, if its
	hash space is too small it tends to stay half full forever, an effect I
	observed in practice.
    </P
><P
>	After some experimentation I came up with a hash function that gives
	reasonably good dispersal of hash keys across the entire 31 bit key
	space.  This improved the average fullness of leaf blocks considerably,
	getting much closer to the theoretical average of 3/4 full.
    </P
><P
>	But the current hash function is just a place holder, waiting for
	an better version based on some solid theory.  I currently favor the
	idea of using crc32 as the default hash function, but I welcome
	suggestions.
    </P
><P
>	Inevitably, no matter how good a hash function I come up with, somebody
	will come up with a better one later.  For this reason the design
	allows for additional hash functiones to be added, with backward
	compatibility.  This is accomplished simply, by including a hash
	function number in the index root.  If a new, improved hash function is
	added, all the previous versions remain available, and previously
	created indexes remain readable.
    </P
><P
>	Of course, the best strategy is to have a good hash function right from
	the beginning.  The initial, quick hack has produced results that
	certainly have not been disappointing.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="CONTRIB-PERFORMANCE"
>2.3.7. Performance</A
></H2
><P
>	OK, if you have read this far then this is no doubt the part you've
	been waiting for.  In short, the performance improvement over normal
	Ext2 has been stunning.  With very small directories performance is
	similar to standard Ext2, but as directory size increases standard
	Ext2 quickly blows up quadratically, while htree-enhanced Ext2
	continues to scale linearly.
    </P
><P
>	Uli Luckas ran benchmarks for file creation in various sizes of
	directories ranging from 10,000 to 90,000 files.  The results are
	pleasing: total file creation time stays very close to linear, versus
	quadratic increase with normal Ext2.
    </P
><P
>	Time to create:
    </P
><DIV
CLASS="FIGURE"
><A
NAME="AEN829"
></A
><P
><B
>Figure 2-3. Performance of Indexed Directories</B
></P
><PRE
CLASS="PROGRAMLISTING"
>		Indexed		Normal
		=======		======
10000 Files:	0m1.350s	0m23.670s
20000 Files:	0m2.720s	1m20.470s
30000 Files:	0m4.330s	3m9.320s
40000 Files:	0m5.890s	5m48.750s
50000 Files:	0m7.040s	9m31.270s
60000 Files:	0m8.610s	13m52.250s
70000 Files:	0m9.980s	19m24.070s
80000 Files:	0m12.060s	25m36.730s
90000 Files:	0m13.400s	33m18.550s
    </PRE
></DIV
><P
>	A graph is posted at: http://www.innominate.org/~phillips/htree/performance.png
    </P
><P
>	All of these tests are CPU-bound, which may come as a surprise.  The
	directories fit easily in cache, and the limiting factor in the case of
	standard Ext2 is the looking up of directory blocks in buffer cache,
	and the low level scan of directory entries.  In the case of htree
	indexing there are a number of costs to be considered, all of them
	pretty well bounded.  Notwithstanding, there are a few obvious
	optimizations to be done:
    </P
><PRE
CLASS="PROGRAMLISTING"
>- Use binary search instead of linear search in the interior index
  nodes.

- If there is only one leaf block in a directory, bypass the index
  probe, go straight to the block.

- Map the directory into the page cache instead of the buffer cache.
    </PRE
><P
>	Each of these optimizations will produce a noticeable improvement in
	performance, but naturally it will never be anything like the big jump
	going from N**2 to Log512(N), ~= N.  In time the optimizations will be
	applied and we can expect to see another doubling or so in performance.
    </P
><P
>	There will be a very slight performance hit when the directory gets big
	enough to need a second level.  Because of caching this will be very
	small.  Traversing the directories metadata index blocks will be a
	bigger cost, and once again, this cost can be reduced by moving the
	directory blocks into the page cache.
    </P
><P
>	Typically, we will traverse 3 blocks to read or write a directory
	entry, and that number increases to 4-5 with really huge directories. 
	But this is really nothing compared to normal Ext2, which traverses
	several hundred blocks in the same situation.
    </P
></DIV
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN838"
>Chapter 3. Inodes, file identifiers</A
></H1
><P
>	Every file, directory, symlink, special device, or anything else really
	stored in a ext2 file system, is identified by an inode.  If you know
	the inode number of the file you want to read, even if you don't know
	the path to the file or even the file name, you can still locate the
	file on disk and read it.
  </P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="INODE-NUMBER"
>3.1. Inode Number</A
></H1
><P
>	The <SPAN
CLASS="QUOTE"
>"inode number"</SPAN
> is an index in the
	<A
HREF="#INODE-TABLE"
>inode table</A
> to an
	<A
HREF="#INODE"
>inode</A
> structure.  The size of the inode table
	is fixed at format time, it is built to hold a maximum number of 
	entries.  Due to the normally sufficiently large amount of entries
	reserved, the table is quite big and thus, it was split equally among
	all the <SPAN
CLASS="QUOTE"
>"block groups"</SPAN
> (see <A
HREF="#DISK-ORGANISATION"
>Chapter 1</A
>
	for more information).
   </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN849"
>3.2. Locating the Inode structure</A
></H1
><P
>	The <A
HREF="#S-INODES-PER-GROUP"
>s_inodes_per_group</A
> field in
	the <A
HREF="#SUPERBLOCK"
>superblock</A
> structure tells us how many
	inodes are defined per group.  Knowing that inode 1 is the first inode
	defined in the inode table, one can use the following formulaes:
   </P
><PRE
CLASS="PROGRAMLISTING"
>group = (inode - 1) / s_inodes_per_group
   </PRE
><P
>	to locate which blocks group holds the part of the inode table containing
	the searched inode entry, and:
   </P
><PRE
CLASS="PROGRAMLISTING"
>index = (inode - 1) % s_inodes_per_group
   </PRE
><P
>	to get the index within this partial inode table to the searched inode
	entry.  Here are a couple of sample values that could be used to test
	your implementation:
   </P
><DIV
CLASS="FIGURE"
><A
NAME="INODE-COMPUTATION"
></A
><P
><B
>Figure 3-1. Sample inode computations</B
></P
><PRE
CLASS="PROGRAMLISTING"
>s_inodes_per_group = 1712

inode number computation
------------ -----------
       1     group = (1 - 1) / 1712 = 0
             index = (1 - 1) % 1712 = 0

       2     group = (2 - 1) / 1712 = 0
             index = (2 - 1) % 1712 = 1

     963     group = (963 - 1) / 1712 = 0
             index = (963 - 1) % 1712 = 962

    1712     group = (1712 - 1) / 1712 = 0
             index = (1712 - 1) % 1712 = 1711

    1713     group = (1713 - 1) / 1712 = 1
             index = (1713 - 1) % 1712 = 0

    3424     group = (3424 - 1) / 1712 = 1
             index = (3424 - 1) % 1712 = 1711

    3425     group = (3425 - 1) / 1712 = 2
             index = (3425 - 1) % 1712 = 0
   </PRE
></DIV
><P
>	As many of you are most likely already familiar with, an index of 0
	means the first entry.  The reason behind using 0 rather than 1 is that
	it can more easily be multiplied by the structure size to find the
	final offset of its location in memory or on disk.
   </P
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN862"
>3.3. Locating the Inode Table</A
></H1
><P
>	As introduced in <A
HREF="#INODE-NUMBER"
>Section 3.1</A
>, the inode table is
	split equally among all group.  If a file system was created to allow
	a thousand inodes, split between 5 groups, there would be 200 inodes
	per partial inode table. <A
HREF="#INODE-COMPUTATION"
>Figure 3-1</A
> illustrates
	such similar distribution.
   </P
><P
>	Each partial inode table can be located using the
	<A
HREF="#BG-INODE-TABLE"
>bg_inode_table</A
> field of the
	<A
HREF="#GROUP-DESCRIPTOR"
>group_descriptor</A
> structure of its
	associated blocks group.
   </P
></DIV
></DIV
><DIV
CLASS="CHAPTER"
><HR><H1
><A
NAME="AEN870"
>Chapter 4. File Attributes</A
></H1
><P
>	Most of the file (also directory, symlink, device...) attributes are
	located in the <A
HREF="#INODE"
>inode</A
> associated with the file.
	Some other attributes are only available as extended attributes.
  </P
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="AEN874"
>4.1. Standard Attributes</A
></H1
><DIV
CLASS="SECT2"
><H2
CLASS="SECT2"
><A
NAME="AEN876"
>4.1.1. SUID, SGID and -rwxrwxrwx</A
></H2
><P
>	There isn't much to say about those, they are located with the SGID and SUID bits in
	<A
HREF="#I-MODE"
>ext2_inode.i_mode</A
>.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN880"
>4.1.2. File Size</A
></H2
><P
>	The size of a file can be determined by looking at the
	<A
HREF="#I-SIZE"
>ext2_inode.i_size</A
> field.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN884"
>4.1.3. Owner and Group</A
></H2
><P
>	Under most implementations, the owner and group are 16bit values, but on
	some recent Linux and Hurd implementations the owner and group id are
	32bit.  When 16bit values are used, only the <SPAN
CLASS="QUOTE"
>"low"</SPAN
> part should
	be used as valid, while when using 32bit value, both the <SPAN
CLASS="QUOTE"
>"low"</SPAN
>
	and <SPAN
CLASS="QUOTE"
>"high"</SPAN
> part should be used, the high part being shifted left
	16 places then added to the low part.
    </P
><P
>	The low part of owner and group are located in
	<A
HREF="#I-UID"
>ext2_inode.i_uid</A
> and
	<A
HREF="#I-GID"
>ext2_inode.i_gid</A
> respectively.
    </P
><P
>	The high part of owner and group are located in
	<A
HREF="#H-I-UID-HIGH"
>ext2_inode.osd2.hurd.h_i_uid_high</A
> and
	<A
HREF="#L-I-GID-HIGH"
>ext2_inode.osd2.hurd.h_i_gid_high</A
>,
	respectively, for Hurd and located in
	<A
HREF="#L-I-UID-HIGH"
>ext2_inode.osd2.linux.l_i_uid_high</A
> and
	<A
HREF="#L-I-GID-HIGH"
>ext2_inode.osd2.linux.l_i_gid_high</A
>,
	respectively, for Linux.
    </P
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="CONTRIB-EXTENDED-ATTRIBUTES"
>4.2. Extended Attributes</A
></H1
><P
>	Extended attributes are name:value pairs associated  permanently  with
	files and directories, similar to the environment  strings  associated
	with a process.  An attribute may be defined or undefined.  If  it  is
	defined, its value  may	be empty or non-empty.
   </P
><P
>	Extended attributes are extensions to the normal attributes which  are
	associated with all inodes in the  system.  They  are  often  used  to
	provide additional  functionality  to  a  filesystem  -  for  example, 
	additional security features such as Access Control Lists  (ACLs)  may
	be implemented using extended attributes.
   </P
><P
>	Extended attributes are accessed as atomic objects. Reading  retrieves
	the whole value of an attribute and stores it  in  a  buffer.  Writing
	replaces any previous value with the new value.
   </P
><P
>	In each ext2 inode, we have the i_file_acl field, reserved  for Access
	Control Lists. This field is used for storing the block  number on
	which the extended attributes of an inode are stored instead (ACLs are
	stored as extended attributes).
   </P
><P
>	Extended attributes are stored on `plain' disk  blocks, which  are not
	part of any files. The disk block layout is similar to the layout used
	for  directories.  After  the  attribute  block header,  entry headers
	follow.  The  size  of  entry headers  varies with  the length  of the
	attribute name.
   </P
><P
>	The attribute values are on the  same block  as their  attribute entry
	descriptions, aligned to the end of the  attribute block.  This allows
	for additional attributes to be added more easily.
   </P
><P
>	A list of attribute names associated with a file can be retrieved. The
	filesystem  handler  returns  a  string  of  names  separated  by null
	characters, terminated by two null characters at the end of the list.
   </P
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN907"
>4.2.1. Attribute Block Header</A
></H2
><DIV
CLASS="FIGURE"
><A
NAME="AEN909"
></A
><P
><B
>Figure 4-1. ext2_xattr_header structure</B
></P
><PRE
CLASS="PROGRAMLISTING"
>offset  size    description
------- ------- -----------
      0       4 <A
HREF="#XATTR-H-MAGIC"
>h_magic</A
>
      4       4 <A
HREF="#XATTR-H-REFCOUNT"
>h_refcount</A
>
      8       4 <A
HREF="#XATTR-H-BLOCKS"
>h_blocks</A
>
     12       4 <A
HREF="#XATTR-H-HASH"
>h_hash</A
>
     16      16 reserved
    </PRE
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="XATTR-H-MAGIC"
>4.2.1.1. h_magic</A
></H3
><P
>	32bit magic number of identification (EXT2_XATTR_MAGIC = 0xEA020000).
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="XATTR-H-REFCOUNT"
>4.2.1.2. h_refcount</A
></H3
><P
>	32bit value used as reference count.  This value is incremented everytime
	a link is created to this attribute block and decremented when a link is
	destroyed.  Whenever this value reaches 0 the attribute block can be freed.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="XATTR-H-BLOCKS"
>4.2.1.3. h_blocks</A
></H3
><P
>	32bit value indicating how many blocks are currently used by the
	extended attributes.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="XATTR-H-HASH"
>4.2.1.4. h_hash</A
></H3
><P
>	32bit hash value of all attributes.
     </P
></DIV
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="AEN928"
>4.2.2. Attribute Entry Header</A
></H2
><DIV
CLASS="FIGURE"
><A
NAME="AEN930"
></A
><P
><B
>Figure 4-2. ext2_xattr_header structure</B
></P
><PRE
CLASS="PROGRAMLISTING"
>offset  size    description
------- ------- -----------
      0       1 <A
HREF="#XATTR-E-NAME-LEN"
>e_name_len</A
>
      1       1 <A
HREF="#XATTR-E-NAME-INDEX"
>e_name_index</A
>
      2       2 <A
HREF="#XATTR-E-VALUE-OFFS"
>e_value_offs</A
>
      4       4 <A
HREF="#XATTR-E-VALUE-BLOCK"
>e_value_block</A
>
      8       4 <A
HREF="#XATTR-E-VALUE-SIZE"
>e_value_size</A
>
     12       4 <A
HREF="#XATTR-E-HASH"
>e_hash</A
>
     16     ... <A
HREF="#XATTR-E-NAME"
>e_name</A
>
    </PRE
></DIV
><P
>	The total size of an attribute entry is always rounded to the
	next 4-bytes boundary.
    </P
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="XATTR-E-NAME-LEN"
>4.2.2.1. e_name_len</A
></H3
><P
>	8bit unsigned value indicating the length of the name.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="XATTR-E-NAME-INDEX"
>4.2.2.2. e_name_index</A
></H3
><P
>	8bit unsigned value used as attribute name index.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="XATTR-E-VALUE-OFFS"
>4.2.2.3. e_value_offs</A
></H3
><P
>	16bit unsigned offset to the value within the value block.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="XATTR-E-VALUE-BLOCK"
>4.2.2.4. e_value_block</A
></H3
><P
>	32bit id of the block holding the value.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="XATTR-E-VALUE-SIZE"
>4.2.2.5. e_value_size</A
></H3
><P
>	32bit unsigned value indicating the size of the attribute value.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="XATTR-E-HASH"
>4.2.2.6. e_hash</A
></H3
><P
>	32bit hash of attribute name and value.
     </P
></DIV
><DIV
CLASS="SECT3"
><HR><H3
CLASS="SECT3"
><A
NAME="XATTR-E-NAME"
>4.2.2.7. e_name</A
></H3
><P
>	Attribute name.
     </P
></DIV
></DIV
></DIV
><DIV
CLASS="SECT1"
><HR><H1
CLASS="SECT1"
><A
NAME="BEHAVIOUR-FLAGS"
>4.3. Behaviour Control Flags</A
></H1
><P
>	The <A
HREF="#I-FLAGS"
>i_flags</A
> value in the
	<A
HREF="#INODE"
>inode</A
> structure allows to  specify how the
	file system should behave in regard to the file.  The following bits
	are currently defined:
   </P
><DIV
CLASS="TABLE"
><A
NAME="AEN967"
></A
><P
><B
>Table 4-1. Behaviour Control Flags</B
></P
><TABLE
BORDER="0"
WIDTH="100%"
CLASS="CALSTABLE"
><TBODY
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
><A
HREF="#EXT2-SECRM-FL"
>EXT2_SECRM_FL</A
></TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x00000001</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>secure deletion</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
><A
HREF="#EXT2-UNRM-FL"
>EXT2_UNRM_FL</A
></TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x00000002</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>record for undelete</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
><A
HREF="#EXT2-COMPR-FL"
>EXT2_COMPR_FL</A
></TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x00000004</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>compressed file</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
><A
HREF="#EXT2-SYNC-FL"
>EXT2_SYNC_FL</A
></TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x00000008</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>synchronous updates</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
><A
HREF="#EXT2-IMMUTABLE-FL"
>EXT2_IMMUTABLE_FL</A
></TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x00000010</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>immutable file</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
><A
HREF="#EXT2-APPEND-FL"
>EXT2_APPEND_FL</A
></TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x00000020</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>append only</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
><A
HREF="#EXT2-NODUMP-FL"
>EXT2_NODUMP_FL</A
></TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x00000040</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>do not dump/delete file</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
><A
HREF="#EXT2-NOATIME-FL"
>EXT2_NOATIME_FL</A
></TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x00000080</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>do not update .i_atime</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
><A
HREF="#EXT2-DIRTY-FL"
>EXT2_DIRTY_FL</A
></TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x00000100</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>dirty (file is in use?)</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
><A
HREF="#EXT2-COMPRBLK-FL"
>EXT2_COMPRBLK_FL</A
></TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x00000200</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>compressed blocks</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
><A
HREF="#EXT2-NOCOMPR-FL"
>EXT2_NOCOMPR_FL</A
></TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x00000400</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>access raw compressed data</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
><A
HREF="#EXT2-ECOMPR-FL"
>EXT2_ECOMPR_FL</A
></TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x00000800</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>compression error</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
><A
HREF="#EXT2-BTREE-FL"
>EXT2_BTREE_FL</A
></TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x00010000</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>b-tree format directory</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
><A
HREF="#EXT2-INDEX-FL"
>EXT2_INDEX_FL</A
></TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x00010000</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>Hash indexed directory</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
><A
HREF="#EXT2-IMAGIC-FL"
>EXT2_IMAGIC_FL</A
></TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x00020000</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>?</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
><A
HREF="#EXT3-JOURNAL-DATA-FL"
>EXT3_JOURNAL_DATA_FL</A
></TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x00040000</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>journal file data</TD
></TR
><TR
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
><A
HREF="#EXT2-RESERVED-FL"
>EXT2_RESERVED_FL</A
></TD
><TD
WIDTH="20%"
ALIGN="LEFT"
VALIGN="TOP"
>0x80000000</TD
><TD
WIDTH="40%"
ALIGN="LEFT"
VALIGN="TOP"
>reserved for ext2 implementation</TD
></TR
></TBODY
></TABLE
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="EXT2-SECRM-FL"
>4.3.1. EXT2_SECRM_FL - Secure Deletion</A
></H2
><P
>	Enabling this bit will cause random data to be written over the flie's
	content several time before the blocks are unlinked.  Note that this
	is highly implementation dependant and as such, it should not be assumed
	to be 100% secure.  Make sure to study the implementation notes before
	relying on this option.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="EXT2-UNRM-FL"
>4.3.2. EXT2_UNRM_FL - Record for Undelete</A
></H2
><P
>	When supported by the implementation, setting this bit will cause the
	deleted data to be moved to a temporary location, where the user can
	restore the original file without any risk of data lost.  This is most
	useful when using ext2 on a desktop or workstation.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="EXT2-COMPR-FL"
>4.3.3. EXT2_COMPR_FL - Compressed File</A
></H2
><P
>	The file's content is compressed.  There is no note about the particular
	algorithm used other than maybe the
	<A
HREF="#S-ALGO-BITMAP"
>s_algo_bitmap</A
> field of the
	<A
HREF="#SUPERBLOCK"
>superblock</A
> structure.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="EXT2-SYNC-FL"
>4.3.4. EXT2_SYNC_FL - Synchronous Updates</A
></H2
><P
>	The file's content in memory will be constantly synchronized with the
	content on disk.  This is mostly used for very sensitive boot files
	or encryption keys that you do not want to lose in case of a crash.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="EXT2-IMMUTABLE-FL"
>4.3.5. EXT2_IMMUTABLE_FL - Immutable File</A
></H2
><P
>	The blocks associated with the file will not be exchanged.  If for
	any reason a file system defragmentation is launched, such files will
	not be moved. Mostly used for stage2 and stage1.5 boot loaders.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="EXT2-APPEND-FL"
>4.3.6. EXT2_APPEND_FL - Append Only</A
></H2
><P
>	Writing can only be used to append content at the end of the file and
	not modify the current content.  Example of such use could be mailboxes,
	where anybody could send a message to a user but not modify any already
	present.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="EXT2-NODUMP-FL"
>4.3.7. EXT2_NODUMP_FL - Do No Dump/Delete</A
></H2
><P
>	Setting this bit will protect the file from deletion.  As long as this
	bit is set, even if the <A
HREF="#I-LINKS-COUNT"
>i_links_count</A
>
	is 0, the file will not be removed.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="EXT2-NOATIME-FL"
>4.3.8. EXT2_NOATIME_FL - Do Not Update .i_atime</A
></H2
><P
>	The <A
HREF="#I-ATIME"
>i_atime</A
> field of the
	<A
HREF="#INODE"
>inode</A
> structure will not be modified when the
	file is accessed if this bit is set.  The only good use I can think of
	that are related to security.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="EXT2-DIRTY-FL"
>4.3.9. EXT2_DIRTY_FL - Dirty</A
></H2
><P
> 	I do not have information at this moment about the use of this bit.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="EXT2-COMPRBLK-FL"
>4.3.10. EXT2_COMPRBLK_FL - Compressed Blocks</A
></H2
><P
>	This flag is set if one or more blocks are compressed.  You can have
	more information about compression on ext2 at
	http://www.netspace.net.au/~reiter/e2compr/  Note that the project has
	not been updated since 1999.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="EXT2-NOCOMPR-FL"
>4.3.11. EXT2_NOCOMPR_FL - Access Raw Compressed Data</A
></H2
><P
>	When this flag is set, the file system implementation will not uncompress
	the data before fowarding it to the application but will rather give it as
	is.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="EXT2-ECOMPR-FL"
>4.3.12. EXT2_ECOMPR_FL - Compression Error</A
></H2
><P
>	This flag is set if an error was detected when trying to uncompress the
	file.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="EXT2-BTREE-FL"
>4.3.13. EXT2_BTREE_FL - B-Tree Format Directory</A
></H2
><P
>	
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="EXT2-INDEX-FL"
>4.3.14. EXT2_INDEX_FL - Hash Indexed Directory</A
></H2
><P
>	When this bit is set, the format of the directory file is hash indexed.
	This is covered in details in <A
HREF="#INDEXED-DIRECTORY"
>Section 2.3</A
>.
    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="EXT2-IMAGIC-FL"
>4.3.15. EXT2_IMAGIC_FL -</A
></H2
><P
>    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="EXT3-JOURNAL-DATA-FL"
>4.3.16. EXT2_JOURNAL_DATA_FL - Journal File Data</A
></H2
><P
>    </P
></DIV
><DIV
CLASS="SECT2"
><HR><H2
CLASS="SECT2"
><A
NAME="EXT2-RESERVED-FL"
>4.3.17. EXT2_RESERVED_FL - Reserved</A
></H2
><P
>    </P
></DIV
></DIV
></DIV
><DIV
CLASS="APPENDIX"
><HR><H1
><A
NAME="AEN1116"
>Appendix A. Credits</A
></H1
><P
>	I would like to personally thank everybody who contributed to this document,
	you are numerous and in many cases I haven't kept track of all of you.  Be
	sure that if you are not in this list, it's a mistake and do not hesitate
	to contact me, it will be a pleasure to add your name to the list.
  </P
><PRE
CLASS="PROGRAMLISTING"
>Andreas Gruenbacher (a.gruenbacher@bestbits.at)
  <A
HREF="#CONTRIB-EXTENDED-ATTRIBUTES"
>Section 4.2</A
>

Daniel Phillips (phillips@innominate.de)
  <A
HREF="#CONTRIB-INDEX-STRUCTURE"
>Section 2.3.1</A
>
  <A
HREF="#CONTRIB-LOOKUP-ALGORITHM"
>Section 2.3.2</A
>
  <A
HREF="#CONTRIB-INSERT-ALGORITHM"
>Section 2.3.3</A
>
  <A
HREF="#CONTRIB-SPLITTING"
>Section 2.3.4</A
>
  <A
HREF="#CONTRIB-KEY-COLLISIONS"
>Section 2.3.5</A
>
  <A
HREF="#CONTRIB-HASH-FUNCTION"
>Section 2.3.6</A
>
  <A
HREF="#CONTRIB-PERFORMANCE"
>Section 2.3.7</A
>

Jeremy Stanley of Access Data Inc.
  Pointed out the inversed values for EXT2_S_IFSOCK and EXT2_S_IFLNK
  </PRE
></DIV
></DIV
></BODY
></HTML
>
